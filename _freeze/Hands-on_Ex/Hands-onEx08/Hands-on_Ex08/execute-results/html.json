{
  "hash": "4baa0d1c61399aa996801680925edd08",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exercise 8\"\nsubtitle: \"Geographical Segmentation with Spatially Constrained Clustering Techniques\"\nauthor: \"Ooi Wen Xian\"\ndate: \"September 17, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  freeze: true\n---\n\n\n# 1.0 Overview\n\nIn this exercises we would delineate homogeneous region by using geographically referenced multivariate data. There are two major analysis, namely:\n\n-   hierarchical cluster analysis; and\n\n-   spatially constrained cluster analysis.\n\n### 1.1 Learning Outcome\n\nThese are the LOs:\n\n-   to convert GIS polygon data into R’s simple feature data.frame by using appropriate functions of **sf** package of R;\n\n-   to convert simple feature data.frame into R’s SpatialPolygonDataFrame object by using appropriate **sf** of package of R;\n\n-   to perform custer analysis by using *hclust()* of Base R;\n\n-   to perform spatially constrained cluster analysis using *skater()* of Base R; and\n\n-   to visualise the analysis output by using **ggplot2** and **tmap** package.\n\n### 1.2 The Analytical Question\n\nIn geobusiness and spatial policy, it is a common practice to delineate the market or planning area into homogeneous regions by using multivariate data. In this hands-on exercise, we are interested to delineate [Shan State](https://en.wikipedia.org/wiki/Shan_State), [Myanmar](https://en.wikipedia.org/wiki/Myanmar) into homogeneous regions by using multiple Information and Communication technology (ICT) measures, namely: Radio, Television, Land line phone, Mobile phone, Computer, and Internet at home.\n\n# 2.0 Data Set-up\n\n## 2.1 The data\n\nTwo data sets will be used in this study. They are:\n\n-   Myanmar Township Boundary Data (i.e. *myanmar_township_boundaries*) : This is a GIS data in ESRI shapefile format. It consists of township boundary information of Myanmar. The spatial data are captured in polygon features.\n\n-   *Shan-ICT.csv*: This is an extract of [**The 2014 Myanmar Population and Housing Census Myanmar**](https://myanmar.unfpa.org/en/publications/2014-population-and-housing-census-myanmar-data-sheet) at the township level.\n\nBoth data sets are download from [Myanmar Information Management Unit (MIMU)](http://themimu.info/)\n\n## 2.2 Installing and loading R packages\n\nBefore we get started, it is important for us to install the necessary R packages into R and launch these R packages into R environment.\n\nThe R packages needed for this exercise are as follows:\n\n-   Spatial data handling\n\n    -   **sf**, **rgdal** and **spdep**\n\n-   Attribute data handling\n\n    -   **tidyverse**, especially **readr**, **ggplot2** and **dplyr**\n\n-   Choropleth mapping\n\n    -   **tmap**\n\n-   Multivariate data visualisation and analysis\n\n    -   **coorplot**, **ggpubr**, and **heatmaply**\n\n-   Cluster analysis\n\n    -   **cluster**\n\n    -   **ClustGeo**\n\nThe code chunks below installs and launches these R packages into R environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(spdep, tmap, sf, ClustGeo,                 ggpubr, cluster, factoextra, NbClust,                heatmaply, corrplot, psych, tidyverse, GGally)  \n```\n:::\n\n\n## 2.2 Data Import and Preparation\n\n### 2.2.1 Importing geospatial data into R environment\n\nIn this section, you will import Myanmar Township Boundary GIS data and its associated attrbiute table into R environment.\n\nThe Myanmar Township Boundary GIS data is in ESRI shapefile format. It will be imported into R environment by using the [*st_read()*](https://www.rdocumentation.org/packages/sf/versions/0.7-2/topics/st_read) function of **sf**.\n\nThe code chunks used are shown below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf <- read_rds(\"data/rds/shan_sf.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 55 features and 22 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 96.15107 ymin: 19.29932 xmax: 101.1699 ymax: 24.15907\nGeodetic CRS:  WGS 84\nFirst 10 features:\n             ST ST_PCODE     DT.x DT_PCODE.x      TS.x  TS_PCODE DT_PCODE.y\n1  Shan (North)   MMR015  Mongmit MMR015D008   Mongmit MMR015017 MMR015D003\n2  Shan (South)   MMR014 Taunggyi MMR014D001   Pindaya MMR014006 MMR014D001\n3  Shan (South)   MMR014 Taunggyi MMR014D001   Ywangan MMR014007 MMR014D001\n4  Shan (South)   MMR014 Taunggyi MMR014D001  Pinlaung MMR014009 MMR014D001\n5  Shan (North)   MMR015  Mongmit MMR015D008    Mabein MMR015018 MMR015D003\n6  Shan (South)   MMR014 Taunggyi MMR014D001     Kalaw MMR014005 MMR014D001\n7  Shan (South)   MMR014 Taunggyi MMR014D001     Pekon MMR014010 MMR014D001\n8  Shan (South)   MMR014 Taunggyi MMR014D001  Lawksawk MMR014008 MMR014D001\n9  Shan (North)   MMR015  Kyaukme MMR015D003 Nawnghkio MMR015013 MMR015D003\n10 Shan (North)   MMR015  Kyaukme MMR015D003   Kyaukme MMR015012 MMR015D003\n       DT.y      TS.y TT_HOUSEHOLDS RADIO    TV LLPHONE MPHONE COMPUTER\n1   Kyaukme   Mongmit         13652  3907  7565     482   3559      166\n2  Taunggyi   Pindaya         17544  7324  8862     348   2849      226\n3  Taunggyi   Ywangan         18348  8890  4781     219   2207       81\n4  Taunggyi  Pinlaung         25504  5908 13816     728   6363      351\n5   Kyaukme    Mabein          8632  3880  6117     628   3389      142\n6  Taunggyi     Kalaw         41341 11607 25285    1739  16900     1225\n7  Taunggyi     Pekon         20084  6399 10762     800   4315      381\n8  Taunggyi  Lawksawk         25957 10048 16353     818   8321      565\n9   Kyaukme Nawnghkio         32224 11257 17657    1239  10409      508\n10  Kyaukme   Kyaukme         28371  5985 17056    1123  10568      878\n   INTERNET RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR INTERNET_PR\n1       321 286.1852 554.1313   35.30618  260.6944    12.15939   23.513038\n2       136 417.4647 505.1300   19.83584  162.3917    12.88190    7.751938\n3       152 484.5215 260.5734   11.93591  120.2856     4.41465    8.284282\n4       737 231.6499 541.7189   28.54454  249.4903    13.76255   28.897428\n5       165 449.4903 708.6423   72.75255  392.6089    16.45042   19.114921\n6      1741 280.7624 611.6204   42.06478  408.7951    29.63160   42.113156\n7       316 318.6118 535.8494   39.83270  214.8476    18.97032   15.733918\n8       556 387.1017 630.0035   31.51366  320.5686    21.76677   21.420041\n9      1216 349.3359 547.9456   38.44960  323.0201    15.76465   37.735849\n10      936 210.9548 601.1773   39.58267  372.4930    30.94709   32.991435\n                         geometry\n1  MULTIPOLYGON (((96.96001 23...\n2  MULTIPOLYGON (((96.7731 21....\n3  MULTIPOLYGON (((96.78483 21...\n4  MULTIPOLYGON (((96.49518 20...\n5  MULTIPOLYGON (((96.66306 24...\n6  MULTIPOLYGON (((96.49518 20...\n7  MULTIPOLYGON (((97.14738 19...\n8  MULTIPOLYGON (((96.94981 22...\n9  MULTIPOLYGON (((96.75648 22...\n10 MULTIPOLYGON (((96.95498 22...\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(shan_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 55\nColumns: 23\n$ ST            <chr> \"Shan (North)\", \"Shan (South)\", \"Shan (South)\", \"Shan (S…\n$ ST_PCODE      <chr> \"MMR015\", \"MMR014\", \"MMR014\", \"MMR014\", \"MMR015\", \"MMR01…\n$ DT.x          <chr> \"Mongmit\", \"Taunggyi\", \"Taunggyi\", \"Taunggyi\", \"Mongmit\"…\n$ DT_PCODE.x    <chr> \"MMR015D008\", \"MMR014D001\", \"MMR014D001\", \"MMR014D001\", …\n$ TS.x          <chr> \"Mongmit\", \"Pindaya\", \"Ywangan\", \"Pinlaung\", \"Mabein\", \"…\n$ TS_PCODE      <chr> \"MMR015017\", \"MMR014006\", \"MMR014007\", \"MMR014009\", \"MMR…\n$ DT_PCODE.y    <chr> \"MMR015D003\", \"MMR014D001\", \"MMR014D001\", \"MMR014D001\", …\n$ DT.y          <chr> \"Kyaukme\", \"Taunggyi\", \"Taunggyi\", \"Taunggyi\", \"Kyaukme\"…\n$ TS.y          <chr> \"Mongmit\", \"Pindaya\", \"Ywangan\", \"Pinlaung\", \"Mabein\", \"…\n$ TT_HOUSEHOLDS <dbl> 13652, 17544, 18348, 25504, 8632, 41341, 20084, 25957, 3…\n$ RADIO         <dbl> 3907, 7324, 8890, 5908, 3880, 11607, 6399, 10048, 11257,…\n$ TV            <dbl> 7565, 8862, 4781, 13816, 6117, 25285, 10762, 16353, 1765…\n$ LLPHONE       <dbl> 482, 348, 219, 728, 628, 1739, 800, 818, 1239, 1123, 310…\n$ MPHONE        <dbl> 3559, 2849, 2207, 6363, 3389, 16900, 4315, 8321, 10409, …\n$ COMPUTER      <dbl> 166, 226, 81, 351, 142, 1225, 381, 565, 508, 878, 2028, …\n$ INTERNET      <dbl> 321, 136, 152, 737, 165, 1741, 316, 556, 1216, 936, 2020…\n$ RADIO_PR      <dbl> 286.18517, 417.46466, 484.52147, 231.64994, 449.49027, 2…\n$ TV_PR         <dbl> 554.1313, 505.1300, 260.5734, 541.7189, 708.6423, 611.62…\n$ LLPHONE_PR    <dbl> 35.306182, 19.835841, 11.935906, 28.544542, 72.752549, 4…\n$ MPHONE_PR     <dbl> 260.69440, 162.39170, 120.28559, 249.49028, 392.60890, 4…\n$ COMPUTER_PR   <dbl> 12.159391, 12.881897, 4.414650, 13.762547, 16.450417, 29…\n$ INTERNET_PR   <dbl> 23.513038, 7.751938, 8.284282, 28.897428, 19.114921, 42.…\n$ geometry      <MULTIPOLYGON [°]> MULTIPOLYGON (((96.96001 23..., MULTIPOLYGO…\n```\n\n\n:::\n:::\n\n\n### 2.2.2 Importing aspatial data into R environment\n\nThe csv file will be import using *read_csv* function of **readr** package.\n\nThe code chunks used are shown below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nict <- read_csv(\"data/aspatial/Shan-ICT.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 55 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): District Pcode, District Name, Township Pcode, Township Name\ndbl (7): Total households, Radio, Television, Land line phone, Mobile phone,...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\nThe imported InfoComm variables are extracted from **The 2014 Myanmar Population and Housing Census Myanmar**. The attribute data set is called *ict*. It is saved in R’s \\* tibble data.frame\\* format.\n\nThe code chunk below reveal the summary statistics of *ict* data.frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(ict)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n District Pcode     District Name      Township Pcode     Township Name     \n Length:55          Length:55          Length:55          Length:55         \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n Total households     Radio         Television    Land line phone \n Min.   : 3318    Min.   :  115   Min.   :  728   Min.   :  20.0  \n 1st Qu.: 8711    1st Qu.: 1260   1st Qu.: 3744   1st Qu.: 266.5  \n Median :13685    Median : 2497   Median : 6117   Median : 695.0  \n Mean   :18369    Mean   : 4487   Mean   :10183   Mean   : 929.9  \n 3rd Qu.:23471    3rd Qu.: 6192   3rd Qu.:13906   3rd Qu.:1082.5  \n Max.   :82604    Max.   :30176   Max.   :62388   Max.   :6736.0  \n  Mobile phone      Computer      Internet at home\n Min.   :  150   Min.   :  20.0   Min.   :   8.0  \n 1st Qu.: 2037   1st Qu.: 121.0   1st Qu.:  88.0  \n Median : 3559   Median : 244.0   Median : 316.0  \n Mean   : 6470   Mean   : 575.5   Mean   : 760.2  \n 3rd Qu.: 7177   3rd Qu.: 507.0   3rd Qu.: 630.5  \n Max.   :48461   Max.   :6705.0   Max.   :9746.0  \n```\n\n\n:::\n:::\n\n\nThere are 11 fields and 55 observation in the tibble data.frame.\n\n### 2.2.3 Importing shan_ict\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_ict <- read_rds(\"data/rds/shan_ict.rds\")\n```\n:::\n\n\n# 3.0 Spatially Constrained Clustering: SKATER approach\n\nIn this section, we would be deriving spatially constrained cluster by using [*skater()*](https://r-spatial.github.io/spdep/reference/skater.html) method of [**spdep**](https://r-spatial.github.io/spdep/index.html) package.\n\n## 3.1 Converting into SpatialPolygonsDataFrame\n\nFirst, `shan_sf` needs to be converted into SpatialPolygonsDataFrame as SKATER function only support **sp** objects such as SpatialPolygonDataFrame.\n\nThe code chunk below uses [*as_Spatial()*](https://r-spatial.github.io/sf/reference/coerce-methods.html) of **sf** package to convert *shan_sf* into a SpatialPolygonDataFrame called *shan_sp*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sp <- as_Spatial(shan_sf)\n```\n:::\n\n\n## 3.2 Computing Neighbour List\n\n[poly2nd()](https://r-spatial.github.io/spdep/reference/poly2nb.html) of **spdep** package will be used to compute the neighbours list from polygon list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan.nb <- poly2nb(shan_sp)\nsummary(shan.nb)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 55 \nNumber of nonzero links: 264 \nPercentage nonzero weights: 8.727273 \nAverage number of links: 4.8 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 \n 5  9  7 21  4  3  5  1 \n5 least connected regions:\n3 5 7 9 47 with 2 links\n1 most connected region:\n8 with 9 links\n```\n\n\n:::\n:::\n\n\nWe can plot the neighbours list on shan_sp by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- st_coordinates(st_centroid(st_geometry(shan_sf)))  \nplot(st_geometry(shan_sf), \n     border=grey(.5))\nplot(shan.nb,\n     coords, \n     col=\"blue\", \n     add=TRUE)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n## 3.3 Computing minimum spanning tree\n\n#### 3.3.1 Calculating edge costs\n\nNext, [*nbcosts()*](https://r-spatial.github.io/spdep/reference/nbcosts.html) of **spdep** package is used to compute the cost of each edge. It is the distance between it nodes. This function compute this distance using a data.frame with observations vector in each node.\n\nThe code chunk below is used to compute the cost of each edge.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlcosts <- nbcosts(shan.nb, shan_ict)\n```\n:::\n\n\nThis process involves calculating the pairwise dissimilarity between each observation's values across five variables and those of its neighboring observation from a neighbor list. These dissimilarities act as generalized weights for a spatial weights matrix.\n\nNext, the computed dissimilarity costs are incorporated into a weights object, similar to how inverse distance weights are calculated. This is done by converting the neighbor list into a list weights object, using the computed costs as weights.\n\nThe `nb2listw()` function from the **spdep** package is used for this conversion. The `style = \"B\"` parameter ensures that the cost values remain unstandardized by rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan.w <- nb2listw(shan.nb, \n                   lcosts, \n                   style=\"B\")\nsummary(shan.w)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 55 \nNumber of nonzero links: 264 \nPercentage nonzero weights: 8.727273 \nAverage number of links: 4.8 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 \n 5  9  7 21  4  3  5  1 \n5 least connected regions:\n3 5 7 9 47 with 2 links\n1 most connected region:\n8 with 9 links\n\nWeights style: B \nWeights constants summary:\n   n   nn       S0       S1        S2\nB 55 3025 76267.65 58260785 522016004\n```\n\n\n:::\n:::\n\n\n## 3.4 Computing minimum spanning tree\n\nThe minimum spanning tree is computed by mean of the [*mstree()*](https://r-spatial.github.io/spdep/reference/mstree.html) of **spdep** package as shown in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan.mst <- mstree(shan.w)\n```\n:::\n\n\nAfter computing the MST, we can check its class and dimension by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(shan.mst)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"mst\"    \"matrix\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(shan.mst)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 54  3\n```\n\n\n:::\n:::\n\n\nThe dimension is 54 and not 55. due to the minimum spanning tree consists on n-1 edges (links) in order to traverse all the nodes.\n\nWe can display the content of *shan.mst* by using *head()* as shown in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(shan.mst)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]      [,3]\n[1,]   12   49  59.69478\n[2,]   12   28  78.78999\n[3,]   28   13  92.79567\n[4,]   13   52 110.55197\n[5,]   49   35 124.74445\n[6,]   35   37  91.65458\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(shan_sf), \n                 border=gray(.5))\nplot.mst(shan.mst, \n         coords, \n         col=\"blue\", \n         cex.lab=0.7, \n         cex.circles=0.005, \n         add=TRUE)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n## 3.5 Computing spatially constrained clusters using SKATER method\n\nThe code chunk below compute the spatially constrained cluster using [*skater()*](https://r-spatial.github.io/spdep/reference/skater.html) of **spdep** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclust6 <- spdep::skater(edges = shan.mst[,1:2], \n                 data = shan_ict, \n                 method = \"euclidean\", \n                 ncuts = 5)\n```\n:::\n\n\nThe *skater()* takes three mandatory arguments: - the first two columns of the MST matrix (i.e. not the cost), - the data matrix (to update the costs as units are being grouped), and - the number of cuts.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(clust6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 8\n $ groups      : num [1:55] 3 3 6 3 3 3 3 3 3 3 ...\n $ edges.groups:List of 6\n  ..$ :List of 3\n  .. ..$ node: num [1:22] 13 48 45 55 52 37 34 16 25 54 ...\n  .. ..$ edge: num [1:21, 1:3] 48 55 45 37 34 16 52 25 13 28 ...\n  .. ..$ ssw : num 3423\n  ..$ :List of 3\n  .. ..$ node: num [1:18] 47 27 53 38 42 15 41 51 43 32 ...\n  .. ..$ edge: num [1:17, 1:3] 53 15 42 38 41 51 15 27 15 43 ...\n  .. ..$ ssw : num 3759\n  ..$ :List of 3\n  .. ..$ node: num [1:11] 2 6 8 1 36 4 10 9 46 5 ...\n  .. ..$ edge: num [1:10, 1:3] 6 1 8 36 4 6 8 10 10 9 ...\n  .. ..$ ssw : num 1458\n  ..$ :List of 3\n  .. ..$ node: num [1:2] 44 20\n  .. ..$ edge: num [1, 1:3] 44 20 95\n  .. ..$ ssw : num 95\n  ..$ :List of 3\n  .. ..$ node: num 23\n  .. ..$ edge: num[0 , 1:3] \n  .. ..$ ssw : num 0\n  ..$ :List of 3\n  .. ..$ node: num 3\n  .. ..$ edge: num[0 , 1:3] \n  .. ..$ ssw : num 0\n $ not.prune   : NULL\n $ candidates  : int [1:6] 1 2 3 4 5 6\n $ ssto        : num 12613\n $ ssw         : num [1:6] 12613 10977 9962 9540 9123 ...\n $ crit        : num [1:2] 1 Inf\n $ vec.crit    : num [1:55] 1 1 1 1 1 1 1 1 1 1 ...\n - attr(*, \"class\")= chr \"skater\"\n```\n\n\n:::\n:::\n\n\nWe can check the cluster assignment by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nccs6 <- clust6$groups \nccs6\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 3 3 6 3 3 3 3 3 3 3 2 1 1 1 2 1 1 1 2 4 1 2 5 1 1 1 2 1 2 2 1 2 2 1 1 3 1 2\n[39] 2 2 2 2 2 4 1 3 2 1 1 1 2 1 2 1 1\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(ccs6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nccs6\n 1  2  3  4  5  6 \n22 18 11  2  1  1 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(5, 5, 2, 2))  # Further increase margins\n\nplot(st_geometry(shan_sf), border = gray(0.5))\nplot(clust6, coords, \n     cex.lab = 0.7, \n     groups.colors = c(\"red\", \"green\", \"blue\", \"brown\", \"pink\"), \n     cex.circles = 0.01,  # Increase circle size if needed\n     add = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1], coords[id2,\n: \"add\" is not a graphical parameter\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1], coords[id2,\n: \"add\" is not a graphical parameter\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1], coords[id2,\n: \"add\" is not a graphical parameter\nWarning in segments(coords[id1, 1], coords[id1, 2], coords[id2, 1], coords[id2,\n: \"add\" is not a graphical parameter\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n## 3.6 Visualising the clusters in choropleth map\n\nThe code chunk below is used to plot the newly derived clusters by using SKATER method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproxmat <- dist(shan_ict, method = 'euclidean')\nhclust_ward <- hclust(proxmat, method = 'ward.D')\ngroups <- as.factor(cutree(hclust_ward, k=6))\n\nshan_sf_cluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER`=`as.matrix.groups.`)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups_mat <- as.matrix(clust6$groups)\nshan_sf_spatialcluster <- cbind(shan_sf_cluster, as.factor(groups_mat)) %>%\n  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)\nqtm(shan_sf_spatialcluster, \"SP_CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\nLet's plot both the hierarchical clustering and spatially constrained hierarchical clustering maps next to each other for easier comparison.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhclust.map <- qtm(shan_sf_cluster,\n                  \"CLUSTER\") + \n  tm_borders(alpha = 0.5) \n\nshclust.map <- qtm(shan_sf_spatialcluster,\n                   \"SP_CLUSTER\") + \n  tm_borders(alpha = 0.5) \n\ntmap_arrange(hclust.map, shclust.map,\n             asp=NA, ncol=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: One tm layer group has duplicated layer types, which are omitted. To\ndraw multiple layers of the same type, use multiple layer groups (i.e. specify\ntm_shape prior to each of them).\nWarning: One tm layer group has duplicated layer types, which are omitted. To\ndraw multiple layers of the same type, use multiple layer groups (i.e. specify\ntm_shape prior to each of them).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n# 4.0 Spatially Constrained Clustering: ClustGeo Method\n\nIn this section, we would use functions provided by **ClustGeo** package to perform non-spatially constrained hierarchical cluster analysis and spatially constrained cluster analysis.\n\n## 4.1 Ward-like hierarchical clustering: ClustGeo\n\nClustGeo package provides function called `hclustgeo()` to perform a typical Ward-like hierarchical clustering just like `hclust()` you learned in previous section.\n\nTo perform non-spatially constrained hierarchical clustering, we only need to provide the function a dissimilarity matrix as shown in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnongeo_cluster <- hclustgeo(proxmat)\nplot(nongeo_cluster, cex = 0.5)\nrect.hclust(nongeo_cluster, \n            k = 6, \n            border = 2:5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\nThe dissimilarity matrix must be an object of class `dist`, i.e. an object obtained with the function `dist()`.\n\n### 4.1.1 Mapping the clusters formed\n\nSimilarly, we can plot the clusters on a categorical area shaded map.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroups <- as.factor(cutree(nongeo_cluster, k=6))\n\nshan_sf_ngeo_cluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n\nqtm(shan_sf_ngeo_cluster, \"CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n### 4.1.2 **Spatially Constrained Hierarchical Clustering**\n\nBefore we can performed spatially constrained hierarchical clustering, a spatial distance matrix will be derived by using [`st_distance()`](https://r-spatial.github.io/sf/reference/geos_measures.html) of sf package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist <- st_distance(shan_sf, shan_sf)\ndistmat <- as.dist(dist)\n```\n:::\n\n\nNext, choicealpha() will be used to determine a suitable value for the mixing parameter alpha as shown in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncr <- choicealpha(proxmat, distmat, range.alpha = seq(0, 1, 0.1), K=6, graph = TRUE)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-29-2.png){width=672}\n:::\n:::\n\n\nWith reference to the graphs above, alpha = 0.2 will be used as shown in the code chunk below. cutree() is used to derive the cluster object. Then, we join back the group list with shan_sf polygon feature data frame by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclustG <- hclustgeo(proxmat, distmat, alpha = 0.2)\n\ngroups <- as.factor(cutree(clustG, k=6))\n\nshan_sf_Gcluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n\nqtm(shan_sf_Gcluster, \"CLUSTER\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n# 5.0 Visual Interpretation of Clusters\n\n## 5.1 Visualising individual clustering variable\n\nCode chunk below is used to reveal the distribution of a clustering variable (i.e RADIO_PR) by cluster.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = shan_sf_ngeo_cluster,\n       aes(x = CLUSTER, y = RADIO_PR)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\nCluster 3 displays the highest mean Radio Ownership Per Thousand Household. This is followed by Cluster 2, 1, 4, 6 and 5.\n\n## 5.2 Multivariate Visualisation\n\nPast studies shown that parallel coordinate plot can be used to reveal clustering variables by cluster very effectively. In the code chunk below, [`ggparcoord()`](https://ggobi.github.io/ggally/reference/ggparcoord.html) of [**GGally**](https://ggobi.github.io/ggally/index.html) package\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggparcoord(data = shan_sf_ngeo_cluster, \n           columns = c(17:21), \n           scale = \"globalminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of ICT Variables by Cluster\") +\n  facet_grid(~ CLUSTER) + \n  theme(axis.text.x = element_text(angle = 30))\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\nThe parallel coordinate plot above reveals that households in Cluster 4 townships tend to own the highest number of TV and mobile-phone. On the other hand, households in Cluster 5 tends to own the lowest of all the five ICT.\n\nIn the code chunk below, group_by() and summarise() of dplyr are used to derive mean values of the clustering variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf_ngeo_cluster %>% \n  st_set_geometry(NULL) %>%\n  group_by(CLUSTER) %>%\n  summarise(mean_RADIO_PR = mean(RADIO_PR),\n            mean_TV_PR = mean(TV_PR),\n            mean_LLPHONE_PR = mean(LLPHONE_PR),\n            mean_MPHONE_PR = mean(MPHONE_PR),\n            mean_COMPUTER_PR = mean(COMPUTER_PR))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  CLUSTER mean_RADIO_PR mean_TV_PR mean_LLPHONE_PR mean_MPHONE_PR\n  <chr>           <dbl>      <dbl>           <dbl>          <dbl>\n1 1               221.        521.            44.2           246.\n2 2               237.        402.            23.9           134.\n3 3               300.        611.            52.2           392.\n4 4               196.        744.            99.0           651.\n5 5               124.        224.            38.0           132.\n6 6                98.6       499.            74.5           468.\n# ℹ 1 more variable: mean_COMPUTER_PR <dbl>\n```\n\n\n:::\n:::\n",
    "supporting": [
      "Hands-on_Ex08_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}